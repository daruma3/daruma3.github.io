<!DOCTYPE html>
<html lamg="ja">

<head>
    <title>SRM659Easy</title>
</head>
<body>
<h1>SRM659Easy</h1>
    <h2>問題概要</h2>
    <p>リンゴとオレンジをN個食べます．食べた果物のうち直近のK個はリンゴがK/2個以下となるようにしたいです．<br>
    また，infoにはリンゴを何番目に食べたかが抜粋されて示されています．最大でリンゴは何個食べられるでしょうか．
    </p>
    <h2>考え方</h2>
    <p>最初K-1個おきに足せば～とかやって詰みました．次にDPを考えましたが一つ前の状況がどう影響するのか整理できませんでした．
    困った結果いもす法に似てるなーと思いそんな感じっぽくやってみたらAC出来ました(知らない).</p>
    <p>NもKも2000以下なので，O(N^2)までは許されます．そのため全部調べたくなります．</p>
    <p>条件を満たすには，ある順番x番を考えた時，x-K+1番からx番までにリンゴが何個あるかを考えます．その合計がK/2個
    となるまでリンゴを追加していけばよいと分かります．自分より前の番号に影響することはないので，1番から順にリンゴの個数を
    決定していけば完成です.
    <h2>実装方針</h2>
    <p>
    リンゴがあらかじめ決まっているところとそうでないところに分けて考えます．リンゴかどうかわからないところはその
    番号が影響する範囲を調べ，すべてK/2未満であれば一個追加します．
    </p>
    <h2>コード</h2>
    <code>
    #include <bits/stdc++.h>
using namespace std;
class ApplesAndOrangesEasy {
	public:
	int maximumApples(int N, int K, vector <int> info) {
        int num[N], ap[N], ans = 0;
        for (int i = 0;i<N;i++){
            num[i]=0;
            ap[i] = 0;
        }
        for (int i = 0; i < info.size();i++){
            ans++;
            ap[info[i] - 1]++;
            for (int k = info[i] - 1; k < info[i]+K-1 and k<N;k++){
                num[k]++;
            }
        }
       
        for (int i = 0; i < N;i++){
            int flag = 1;
            if(num[i]<=K/2 and ap[i]==0){
                for (int j = 0; j < K and i+j<N;j++){
                    if(num[i+j]>=K/2)
                        flag = -1;
                }
                if(flag>0){
                    ans++;
                    for (int j = 0; j < K and i+j<N; j++)
                    {
                        num[i + j]++;
                    }
                }
            }
        }
        return ans;
    }
};
</code>
</body>